/** @file Build Style Dictionary outputs and derive Tailwind + DaisyUI artefacts.
 *
 * This script performs three duties:
 * 1. Ask Style Dictionary to emit a generic CSS variables file (for manual inspection).
 * 2. Generate richer assets consumed by the app:
 *    - `dist/tokens.css` (runtime CSS variables + `@theme` + DaisyUI theme plugins).
 *    - `dist/tailwind.theme.cjs` (CommonJS export describing `theme.extend` fragments
 *      and DaisyUI metadata).
 *    - `dist/tw/preset.js` and `dist/daisy/theme.js` (legacy ESM exports preserved
 *      for incidental tooling that may already read them).
 * 3. Provide guard rails (reference resolution, alias generation) so tokens stay
 *    human-friendly while emitting strict values for tooling.
 */

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import StyleDictionary from "style-dictionary";
import { readJson } from "../build-utils/read-json.js";

const ROOT_PATH = fileURLToPath(new URL("..", import.meta.url));
const DIST_PATH = path.join(ROOT_PATH, "dist");
const THEMES_DIR_URL = new URL("../src/themes/", import.meta.url);
const GENERATED_BANNER =
  "/* Auto-generated by tokens/build/style-dictionary.js — do not edit manually. */\n";
const GENERATED_LINE =
  "// Auto-generated by tokens/build/style-dictionary.js — do not edit manually.";

// Ensure Style Dictionary resolves relative paths from the tokens package root.
process.chdir(ROOT_PATH);

const collator = new Intl.Collator("en", { numeric: true, sensitivity: "base" });

const styleDictionary = new StyleDictionary({
  source: ["src/tokens.json"],
  platforms: {
    css: {
      transformGroup: "css",
      buildPath: "dist/css/",
      files: [{ destination: "variables.css", format: "css/variables" }],
    },
  },
});

styleDictionary.buildPlatform("css");

/**
 * Recursively strip `{ value }` wrappers while preserving key ordering.
 *
 * @param {unknown} input - Token node to unwrap.
 * @returns {unknown} Unwrapped token tree.
 */
function unwrap(input) {
  if (input === null || typeof input !== "object") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map(unwrap);
  }
  if (Object.prototype.hasOwnProperty.call(input, "value")) {
    return input.value;
  }
  return Object.fromEntries(
    Object.entries(input)
      .sort(([a], [b]) => collator.compare(a, b))
      .map(([key, value]) => [key, unwrap(value)]),
  );
}

/**
 * Flatten a token tree into lookup map entries (`path.to.leaf` -> value).
 *
 * @param {unknown} node - Current node.
 * @param {string[]} pathParts - Path segments accumulated so far.
 * @param {Map<string, unknown>} target - Map collecting flattened entries.
 */
function flattenLookup(node, pathParts, target) {
  if (node === null || typeof node !== "object" || Array.isArray(node)) {
    if (pathParts.length > 0) {
      target.set(pathParts.join("."), node);
    }
    return;
  }
  for (const [key, value] of Object.entries(node)) {
    flattenLookup(value, [...pathParts, key], target);
  }
}

/**
 * Resolve `{token.path}` references using the provided lookup.
 *
 * @param {unknown} input - Value or nested structure to resolve.
 * @param {Map<string, unknown>} lookup - Token lookup map.
 * @param {Set<string>} stack - Detection set to guard against circular refs.
 * @returns {unknown} Value with references resolved.
 */
function resolveReferences(input, lookup, stack = new Set()) {
  if (typeof input === "string") {
    const match = input.match(/^\{([^}]+)\}$/);
    if (!match) {
      return input;
    }
    const pathKey = match[1];
    if (stack.has(pathKey)) {
      throw new Error(`Circular token reference detected: ${[...stack, pathKey].join(" -> ")}`);
    }
    if (!lookup.has(pathKey)) {
      throw new Error(`Unknown token reference "${pathKey}"`);
    }
    return resolveReferences(lookup.get(pathKey), lookup, new Set([...stack, pathKey]));
  }
  if (Array.isArray(input)) {
    return input.map((value) => resolveReferences(value, lookup, new Set(stack)));
  }
  if (input && typeof input === "object") {
    return Object.fromEntries(
      Object.entries(input).map(([key, value]) => [
        key,
        resolveReferences(value, lookup, new Set(stack)),
      ]),
    );
  }
  return input;
}

/**
 * Convert a string of comma-separated fonts into a Tailwind-ready array.
 *
 * @param {string | undefined} fontList - Comma separated font list.
 * @returns {string[]} Normalised font family entries.
 */
function toFontArray(fontList) {
  if (!fontList) return [];
  return fontList
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean)
    .map((entry) => entry.replace(/^"(.*)"$/, "$1"));
}

/**
 * Produce a human-friendly title from kebab/underscore notation.
 *
 * @param {string} name - Input string.
 * @returns {string} Title cased string.
 */
function toTitleCase(name) {
  return name
    .replace(/[_-]+/g, " ")
    .split(" ")
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join(" ");
}

/**
 * Write content to `dist/<relativePath>`, ensuring the parent directory exists.
 *
 * @param {string} relativePath - Target path relative to `dist/`.
 * @param {string} content - File content.
 */
function writeDistFile(relativePath, content) {
  const target = path.join(DIST_PATH, relativePath);
  fs.mkdirSync(path.dirname(target), { recursive: true });
  fs.writeFileSync(target, content, "utf8");
}

/**
 * Format a CSS block with consistent indentation.
 *
 * @param {string} selector - CSS selector.
 * @param {Record<string, string>} declarations - Declarations map.
 * @returns {string} Formatted CSS block.
 */
function formatCssBlock(selector, declarations) {
  const lines = Object.entries(declarations)
    .sort(([a], [b]) => collator.compare(a, b))
    .map(([key, value]) => `  ${key}: ${value};`)
    .join("\n");
  return `${selector} {\n${lines}\n}\n`;
}

/**
 * Derive CSS, DaisyUI, and Tailwind artefacts for a resolved theme.
 *
 * @param {ThemeMeta} meta - Theme metadata.
 * @param {Record<string, any>} semantic - Resolved semantic tokens.
 * @param {ResolvedTokens} resolvedTokens - Full resolved token catalogue.
 * @returns {ThemeArtifacts} Artefact descriptor.
 */
function deriveThemeArtifacts(meta, semantic, resolvedTokens) {
  const neutral = resolvedTokens.color?.neutral ?? {};
  const radius = resolvedTokens.radius ?? {};

  const base100 = semantic.bg?.default ?? neutral["50"] ?? "#ffffff";
  const base200 = semantic.bg?.subtle ?? neutral["0"] ?? base100;
  const base300 = semantic.bg?.muted ?? neutral["100"] ?? base200;
  const baseOverlay = semantic.bg?.overlay ?? neutral["200"] ?? base300;
  const baseContent = semantic.fg?.default ?? neutral["900"] ?? "#111111";
  const baseContentMuted = semantic.fg?.muted ?? neutral["600"] ?? baseContent;

  const brandDefault =
    semantic.brand?.default ?? resolvedTokens.color?.primary?.["500"] ?? "#F97316";
  const brandHover =
    semantic.brand?.hover ?? resolvedTokens.color?.primary?.["600"] ?? brandDefault;
  const brandContrast = semantic.brand?.contrast ?? neutral["0"] ?? "#ffffff";

  const accentDefault =
    semantic.accent?.default ?? resolvedTokens.color?.secondary?.["500"] ?? brandDefault;
  const accentHover =
    semantic.accent?.hover ?? resolvedTokens.color?.secondary?.["600"] ?? accentDefault;
  const accentContrast = semantic.accent?.contrast ?? baseContent;

  const status = semantic.status ?? {};
  const infoDefault = status.info?.default ?? resolvedTokens.color?.info?.["500"] ?? accentDefault;
  const infoContrast = status.info?.contrast ?? baseContent;
  const successDefault =
    status.success?.default ?? resolvedTokens.color?.success?.["500"] ?? "#22C55E";
  const successContrast = status.success?.contrast ?? baseContent;
  const warningDefault =
    status.warning?.default ?? resolvedTokens.color?.warning?.["500"] ?? "#EAB308";
  const warningContrast = status.warning?.contrast ?? baseContent;
  const errorDefault = status.error?.default ?? resolvedTokens.color?.error?.["500"] ?? "#F43F5E";
  const errorContrast = status.error?.contrast ?? baseContent;

  const coreVariables = {
    "--border": "1px",
    "--depth": "0",
    "--noise": "0",
    "--radius-badge": radius.full ?? "9999px",
    "--radius-box": radius.lg ?? "1rem",
    "--radius-btn": radius.md ?? "0.5rem",
    "--color-base-100": base100,
    "--color-base-200": base200,
    "--color-base-300": base300,
    "--color-base-overlay": baseOverlay,
    "--color-base-content": baseContent,
    "--color-base-content-muted": baseContentMuted,
    "--color-primary": brandDefault,
    "--color-primary-content": brandContrast,
    "--color-primary-hover": brandHover,
    "--color-secondary": accentDefault,
    "--color-secondary-content": accentContrast,
    "--color-accent": accentHover,
    "--color-accent-content": accentContrast,
    "--color-neutral": baseOverlay,
    "--color-neutral-content": baseContent,
    "--color-info": infoDefault,
    "--color-info-content": infoContrast,
    "--color-success": successDefault,
    "--color-success-content": successContrast,
    "--color-warning": warningDefault,
    "--color-warning-content": warningContrast,
    "--color-error": errorDefault,
    "--color-error-content": errorContrast,
  };

  const aliasVariables = {
    "--a": "var(--color-accent)",
    "--ac": "var(--color-accent-content)",
    "--b1": "var(--color-base-100)",
    "--b2": "var(--color-base-200)",
    "--b3": "var(--color-base-300)",
    "--bc": "var(--color-base-content)",
    "--bcm": "var(--color-base-content-muted)",
    "--in": "var(--color-info)",
    "--inc": "var(--color-info-content)",
    "--n": "var(--color-neutral)",
    "--nc": "var(--color-neutral-content)",
    "--p": "var(--color-primary)",
    "--pc": "var(--color-primary-content)",
    "--pf": "var(--color-primary-hover)",
    "--s": "var(--color-secondary)",
    "--sc": "var(--color-secondary-content)",
    "--su": "var(--color-success)",
    "--suc": "var(--color-success-content)",
    "--wa": "var(--color-warning)",
    "--wac": "var(--color-warning-content)",
    "--er": "var(--color-error)",
    "--erc": "var(--color-error-content)",
  };

  const cssVariables = { ...coreVariables, ...aliasVariables };

  return {
    meta,
    semantic,
    coreVariables,
    aliasVariables,
    cssVariables,
    daisyTheme: {
      name: meta.name,
      displayName: meta.displayName,
      default: Boolean(meta.default),
      prefersDark: Boolean(meta.prefersDark),
      prefersLight: Boolean(meta.prefersLight),
      colorScheme: meta.colorScheme ?? null,
      variables: coreVariables,
    },
  };
}

// Load token catalogue and prepare lookup tables
const tokensSource = readJson(new URL("../src/tokens.json", import.meta.url));
const tokensUnwrapped = unwrap(tokensSource);
const tokenLookup = new Map();
flattenLookup(tokensUnwrapped, [], tokenLookup);
const resolvedTokens = resolveReferences(tokensUnwrapped, tokenLookup);

const fontFamilies = Object.fromEntries(
  Object.entries(resolvedTokens.font?.family ?? {}).map(([key, value]) => [
    key,
    toFontArray(value),
  ]),
);

// Load theme definitions
const themeFiles = fs
  .readdirSync(fileURLToPath(THEMES_DIR_URL))
  .filter((fileName) => fileName.endsWith(".json"))
  .sort((a, b) => collator.compare(a, b));

const themes = themeFiles.map((fileName) => {
  const rawTheme = readJson(new URL(fileName, THEMES_DIR_URL));
  const name = rawTheme.name ?? path.basename(fileName, ".json").toLowerCase().replace(/\s+/g, "-");
  const meta = {
    name,
    displayName: rawTheme.displayName ?? toTitleCase(name),
    default: Boolean(rawTheme.default),
    prefersDark: Boolean(rawTheme.prefersDark),
    prefersLight: Boolean(rawTheme.prefersLight),
    colorScheme: rawTheme.colorScheme,
  };
  const semantic = resolveReferences(unwrap(rawTheme.semantic ?? {}), tokenLookup);
  return deriveThemeArtifacts(meta, semantic, resolvedTokens);
});

// Build CSS payload (`tokens/dist/tokens.css`)
const rootDeclarations = {};
for (const [key, value] of Object.entries(resolvedTokens.space ?? {})) {
  rootDeclarations[`--space-${key}`] = value;
}
for (const [key, value] of Object.entries(resolvedTokens.radius ?? {})) {
  rootDeclarations[`--radius-${key}`] = value;
}
for (const [key, value] of Object.entries(resolvedTokens.font?.size ?? {})) {
  rootDeclarations[`--font-size-${key}`] = value;
}
for (const [key, value] of Object.entries(resolvedTokens.font?.family ?? {})) {
  rootDeclarations[`--font-family-${key}`] = value;
}

let tokensCss = `${GENERATED_BANNER}${formatCssBlock(":root", rootDeclarations)}\n`;

const daisyPluginThemes = themes.map((theme) => {
  const flags = [];
  if (theme.meta.default) flags.push("--default");
  if (theme.meta.prefersDark) flags.push("--prefersdark");
  if (theme.meta.prefersLight) flags.push("--preferslight");
  return `${theme.meta.name}${flags.length ? ` ${flags.join(" ")}` : ""}`;
});

if (daisyPluginThemes.length > 0) {
  tokensCss += '@plugin "daisyui" {\n';
  tokensCss += "  themes:\n";
  tokensCss += daisyPluginThemes
    .map((entry, index) => `    ${entry}${index < daisyPluginThemes.length - 1 ? "," : ";"}`)
    .join("\n");
  tokensCss += "\n}\n\n";
}

for (const theme of themes) {
  const selector = `:root[data-theme="${theme.meta.name}"],\n[data-theme="${theme.meta.name}"]`;
  tokensCss += `/* Theme: ${theme.meta.displayName} (${theme.meta.name}) */\n`;
  tokensCss += `${formatCssBlock(selector, theme.cssVariables)}\n`;
  tokensCss += `@theme ${theme.meta.name} {\n`;
  tokensCss += Object.entries(theme.cssVariables)
    .sort(([a], [b]) => collator.compare(a, b))
    .map(([key, value]) => `  ${key}: ${value};`)
    .join("\n");
  tokensCss += "\n}\n\n";

  const pluginDeclarations = {
    name: `"${theme.meta.name}"`,
    ...(theme.meta.default ? { default: "true" } : {}),
    ...(theme.meta.prefersDark ? { prefersdark: "true" } : {}),
    ...(theme.meta.prefersLight ? { preferslight: "true" } : {}),
    ...(theme.meta.colorScheme ? { "color-scheme": theme.meta.colorScheme } : {}),
  };

  tokensCss += '@plugin "daisyui/theme" {\n';
  tokensCss += Object.entries(pluginDeclarations)
    .map(([key, value]) => `  ${key}: ${value};`)
    .join("\n");
  if (Object.keys(pluginDeclarations).length > 0) {
    tokensCss += "\n";
  }
  tokensCss += Object.entries(theme.coreVariables)
    .sort(([a], [b]) => collator.compare(a, b))
    .map(([key, value]) => `  ${key}: ${value};`)
    .join("\n");
  tokensCss += "\n}\n\n";
}

writeDistFile("tokens.css", tokensCss);

// Build Tailwind + DaisyUI exports (`tokens/dist/tailwind.theme.cjs`)
const tailwindExtend = {
  spacing: resolvedTokens.space ?? {},
  borderRadius: resolvedTokens.radius ?? {},
  colors: resolvedTokens.color ?? {},
  fontFamily: fontFamilies,
  fontSize: resolvedTokens.font?.size ?? {},
};

const tailwindThemeCjs = [
  GENERATED_LINE,
  "",
  `const tailwind = ${JSON.stringify({ extend: tailwindExtend }, null, 2)};`,
  `const daisyThemes = ${JSON.stringify(
    themes.map((theme) => ({
      name: theme.meta.name,
      displayName: theme.meta.displayName,
      default: theme.meta.default ?? false,
      prefersDark: theme.meta.prefersDark ?? false,
      prefersLight: theme.meta.prefersLight ?? false,
      colorScheme: theme.meta.colorScheme ?? null,
      variables: theme.coreVariables,
    })),
    null,
    2,
  )};`,
  `const themeNames = ${JSON.stringify(
    themes.map((theme) => theme.meta.name),
    null,
    2,
  )};`,
  "",
  "module.exports = { tailwind, daisyThemes, themeNames };",
  "",
].join("\n");

writeDistFile("tailwind.theme.cjs", tailwindThemeCjs);

// Legacy ESM exports (`dist/tw/preset.js` and `dist/daisy/theme.js`)
const presetEsm = `export default ${JSON.stringify({ theme: tailwindExtend }, null, 2)};\n`;
writeDistFile("tw/preset.js", presetEsm);

const daisyThemeEsm = `export default ${JSON.stringify(
  { themes: themes.map((theme) => ({ name: theme.meta.name, ...theme.coreVariables })) },
  null,
  2,
)};\n`;
writeDistFile("daisy/theme.js", daisyThemeEsm);

/**
 * @typedef {ReturnType<typeof deriveThemeArtifacts>} ThemeArtifacts
 * @typedef {{
 *   extend: Record<string, unknown>
 * }} TailwindExtend
 * @typedef {ReturnType<typeof resolveReferences>} ResolvedTokens
 * @typedef {{
 *   name: string;
 *   displayName: string;
 *   default?: boolean;
 *   prefersDark?: boolean;
 *   prefersLight?: boolean;
 *   colorScheme?: string | null;
 * }} ThemeMeta
 */
